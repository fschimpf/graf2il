import xml.etree.ElementTree as ET
import sys


filename = sys.argv[1] #get filename for xml-file from command line
print
print 'graf2il - converts a JGrafchart xml-file to Siemens Step 7 awl-file'
print 'Fritz Schimpf, version 0.1'
print
print 'opening file: ', filename
print

# parse XML with ElementTree
tree = ET.parse(filename)
root = tree.getroot()

# create output file and write header. FIX: ask for overwrite
outfile = open('testoutput.awl', 'w')
outfile.write ('ORGANIZATION_BLOCK MAIN:OB1\nTITLE=PROGRAM COMMENTS\nBEGIN\n')
outfile.write ('// *** BEGIN of autogenerated code from graf2il ***\n')

print 'found input(s):'
digInDict = {}                          #create dictionary for digital Inputs
for din in root.findall('DigitalIn'):
    channel = din.get('channel')    
    name = din.get('name')
    digInDict[name] = channel
print digInDict
print
print 'found output(s):'
digOutDict = {}                          #create dictionary for digital outputs
for dout in root.findall('DigitalOut'):
    channel = dout.get('channel')    
    name = dout.get('name')
    digOutDict[name] = channel
print digOutDict
print

MDict = {}                               # create Dictonary for PLC-Memory-Bits
nextM = 0                                # counter for next unused Memory-Bit

def mem(n):
    "Generate memory-bit-notation (e.g. M0.0) from number of memory-bit (Mx.y)"
    mBit = (n / 8, n % 8)
    memstring = 'M{0[0]}.{0[1]}'.format(mBit)
    return memstring

print 'found initial step:'
# Fix: Fehler abfangen: Kein Initial Step / mehrere
for initialStep in root.findall('GCInitialStep'):
    name = initialStep.get('name')
    action = initialStep.get('actionText')
    eid = initialStep.get('id')
    print name, action, eid
    nameString = 'Initial_Step_{0}'.format(name)    # generate name-sring for State
    MDict[nameString] = mem(nextM)                  # add name and M to dictionary
    nextM = nextM + 1
print
print 'found step(s):'
n = 1
for step in root.findall('GCStep'):
    name = step.get('name')
    action = step.get('actionText')
    eid = step.get('id')
    print name, action, eid
    nameString = 'Step_{0}_{1}'.format(n, name)    # generate name-sring for State
    MDict[nameString] = mem(nextM)                  # add name and M to dictionary
    nextM = nextM + 1
    n = n + 1
print
print 'found transition(s):'
for transition in root.findall('GCTransition'):
    name = transition.get('actionText')
    eid = transition.get('id')
    print name, eid
    # Fix: Richtigen Namen erzeugen!    
    nameString = 'Transition_{0}_{1}'.format(n, name)    # generate name-sring for State
    MDict[nameString] = mem(nextM)                  # add name and M to dictionary
    nextM = nextM + 1
print
print 'found link(s):'
for link in root.findall('GCLink'):
    fromId = link.get('fromObject')
    toId = link.get('toObject')
    print fromId, toId
print
print 'Created memory list:'
print MDict
print


outfile.write ('// *** END of autogenerated code from graf2il ***\n')
outfile.write('END_ORGANIZATION_BLOCK\nSUBROUTINE_BLOCK SBR_0:SBR0\nTITLE=SUBROUTINE COMMENTS\nBEGIN\nNetwork 1 // Network Title\n// Network Comment\nEND_SUBROUTINE_BLOCK\nINTERRUPT_BLOCK INT_0:INT0\nTITLE=INTERRUPT ROUTINE COMMENTS\nBEGIN\nNetwork 1 // Network Title\n// Network Comment\nEND_INTERRUPT_BLOCK\n')
outfile.close()

