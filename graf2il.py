import xml.etree.ElementTree as ET
import sys


filename = sys.argv[1] #get filename for xml-file from command line
print
print 'graf2il - converts a JGrafchart xml-file to Siemens Step 7 awl-file'
print 'Fritz Schimpf, version 0.2'
print
print 'opening file: ', filename
print

# parse XML with ElementTree
tree = ET.parse(filename)
root = tree.getroot()

# create output file and write header. FIX: ask for overwrite
outfilename = filename.partition('.')[0] + '.awl'
outfile = open(outfilename, 'w')
outfile.write ('ORGANIZATION_BLOCK MAIN:OB1\nTITLE=Autogenerated by Graf2il\nBEGIN\n')

digInDict = {}                          #create dictionary for digital Inputs
for din in root.findall('DigitalIn'):
    channel = din.get('channel')    
    name = din.get('name')
    digInDict[name] = channel

digOutDict = {}                          #create dictionary for digital outputs
for dout in root.findall('DigitalOut'):
    channel = dout.get('channel')    
    name = dout.get('name')
    digOutDict[name] = channel

print 'found in- and outputs:'
for i in sorted(digInDict):
    print digInDict[i].ljust(5), i
for i in sorted(digOutDict):
    print digOutDict[i].ljust(5), i
print

nextM = 0           # counter for next unused Memory-Bit
nextStep = 0        # Step-counter  
nextNetwork = 1     # Network-counter for output file                         

def mem(n):
    "Generate memory-bit-notation (e.g. M0.0) from number of memory-bit (Mx.y)"
    mBit = (n / 8, n % 8)
    memstring = 'M{0[0]}.{0[1]}'.format(mBit)
    return memstring


# Parse Steps from XML
# Fix: Fehler abfangen: Kein Initial Step / mehrere
print 'found step(s):'
stepList = []                                 # create empty list for storing transition data

for initialStep in root.findall('GCInitialStep'):
    name = initialStep.get('name')
    action = initialStep.get('actionText')
    eid = initialStep.get('id')
    nameString = 'Initial_Step_{0}'.format(name)    # generate name-sring for State

    # Add step to stepList    
    thisStep = nextStep, nameString, action, eid, mem(nextM)
    stepList.append(thisStep)

    nextM = nextM + 1
    nextStep = nextStep + 1

for step in root.findall('GCStep'):
    name = step.get('name')
    action = step.get('actionText')
    eid = step.get('id')
    nameString = 'Step_{0}_{1}'.format(nextStep, name)    # generate name-sring for State
     
    # Add step to stepList    
    thisStep = nextStep, nameString, action, eid, mem(nextM)
    stepList.append(thisStep)
    
    nextM = nextM + 1
    nextStep = nextStep + 1

for thisStep in stepList:
    n, name, action, eid, memory = thisStep    
    print str(n).ljust(3), memory.ljust(5), name
print


def findStepEid(eid, sList):
    "Find step with ID-String eid from unsorted stepList"
    for step in sList:
        number, name, action, stepEid, memory = step         
        if stepEid != eid:                          # id we are looking for is not found, ...
            returnStep = []                         # make empty return
        else:
            returnStep = step                       # found, return current step and
            break                                   # exit for-loop
    if returnStep == []:
        raise NameError, 'Step-id not found in stepList' 
    return (returnStep)


# Parse Transitions from XML
print 'found transitions:'
nTransition = 0                                     # counter for Transitions
transitionList = []                                 # create empty list for storing transition data
for transition in root.findall('GCTransition'):
    nTransition = nTransition + 1
    name = transition.get('actionText')
    eid = transition.get('id')
    
    # find links to steps:    
    for link in root.findall('GCLink'):
        fromId = link.get('fromObject')
        if fromId == eid:
            toStepEid = link.get('toObject')           # Transition geht zu toStep
            break;
    for link in root.findall('GCLink'):
        toId = link.get('toObject')
        if toId == eid:
            fromStepEid = link.get('fromObject')       # Transition kommt von fromStep
            break;

    # find Step numbers from IDs
    fromStep = findStepEid(fromStepEid, stepList)     # find step with right id  
    fromStepn = fromStep[0]                           # step-number is in element 0 of tuple  

    toStep = findStepEid(toStepEid, stepList)     # find step with right id  
    toStepn = toStep[0]                           # step-number is in element 0 of tuple  

    nameString = 'Transition_{0}_{1}'.format(fromStepn, toStepn)    # generate name-sring for Transition
        
    # evaluate condition (so far only support for one condition, check if true)
    condition = digInDict[name]    


    thisTransition = nTransition, nameString, eid, fromStepn, toStepn, condition, mem(nextM)     # pack tuple with transition info
    nextM = nextM + 1
    transitionList.append(thisTransition)                            # add new transition to list


    # write transition definitions to awl-file 
    outfile.write ('Network {0} // {1}\n'.format(nextNetwork, nameString))
    nextNetwork = nextNetwork + 1

    outfile.write ('LD      {0}\n'.format(fromStep[4]))       # LD fromStep memory (in element 4)
    outfile.write ('A       {0}\n'.format(condition))         # A condition
    outfile.write ('=       {0}\n'.format(thisTransition[6])) # = Mem (thisTransition) (in element 6)

for thisTransition in transitionList:
    nTransition, name, eid, fromStepn, toStepn, condition, memory = thisTransition
    print str(nTransition).ljust(3), memory.ljust(5), name


print
print 'generating initial condition:'
outfile.write ('Network {0} // Initial condition\n'.format(nextNetwork))
nextNetwork = nextNetwork + 1
nStep = 0
for step in stepList:
    if nStep == 0:      # initial step, do nothing
        a = 1
    elif nStep == 1:    # first step:
        outfile.write ('LDN     {0}\n'.format(step[4]))     # LDN step-memory for first step. Mem is in element 4.
    else:
        outfile.write ('AN      {0}\n'.format(step[4]))     # LD for all other steps
    nStep = nStep + 1

outfile.write ('=       {0}\n'.format(stepList[0][4]))      # = mem of initial step. This is in list-element 0, Mem is in step-element 4.

print '... done'
print


def findStepN(n, sList):
    "Find tuple step from unsorted stepList which has index n"
    for step in sList:
        number, name, action, eid, memory = step         
        if number != n:                             # in number we are looking for is not found, ...
            returnStep = []                         # make empty return
        else:
            returnStep = step                       # found, return current step and
            break                                   # exit for-loop
    if returnStep == []:
        raise NameError, 'Step index not found' 
    return (returnStep)

def findTransitionsFromStep (n, tList):
    "Find all transitions originating from step n"
    returnTransitions = []              # create empty List for returning result    
    for transition in tList:
        nTr, nameTr, eidTr, fromStepNTr, toStepNTr, PLCInputTr, memoryTr = transition   # unpack current transition
        if fromStepNTr == n:
            returnTransitions.append(transition)    # append current transition if fromStep matches index
    if returnTransitions == []:
        raise NameError, 'No transition from Step x found.'
    return (returnTransitions)    
    

for thisTransition in transitionList:
    nTransition, name, eid, fromStepN, toStepN, PLCInput, memory = thisTransition # unpack info about current transition
    
    toStep = findStepN(toStepN, stepList)   # find info about next Step

    toStepN, toStepName, toStepAction, toStepEid, toStepMemory = toStep # unpack info about toStep

    nextTransitions = findTransitionsFromStep (toStepN, transitionList) # find next Transition(s)


    # write the stuff into awl
    outfile.write ('Network {0} // {1} activates {2}\n'.format(nextNetwork, name, toStepName))
    nextNetwork = nextNetwork + 1    

    outfile.write ('LD      {0}\n'.format(memory))              #LD M_transition
    outfile.write ('O       {0}\n'.format(toStepMemory))        # O M_toStep

    # tricky part: add all following transistions away from toStep as NOTs
    for nextTran in nextTransitions:
        outfile.write ('AN      {0}\n'.format(nextTran[6]))     # AN memory of nextTran (mem is element no. 6)
    outfile.write ('=       {0}\n'.format(toStepMemory))        # network activates next Step


print '... done'
print

print 'generating output networks'
def parse_actions (actionstring, outputfile, outDict):
    actionstring = actionstring.strip()    
    separated = actionstring.partition(';')
    action = separated[0].strip()
    remainder = separated[2].strip()    
    separated = action.partition('=')
    output = separated[0].strip()
    setReset = separated[2].strip()
    separated = output.partition(' ')
    if separated[0] == 'S':
        output = separated[2].strip()
        if setReset == '1':
            outputfile.write ('S       {0}, 1\n'.format(outDict[output]))   #set output
        elif setReset == '0':
            outputfile.write ('R       {0}, 1\n'.format(outDict[output]))   #reset output
        else:
            raise NameError, 'unsupported output value'
    else:
        raise NameError, 'unsupported output action'
    if remainder != '':
        parse_actions (remainder, outputfile, outDict)


nextStep = 0
    
for step in stepList:
    n, name, action, eid, memory = step

    if action != '':  
        outfile.write ('Network {0} // set outputs for {1}\n'.format(nextNetwork, name))
        nextNetwork = nextNetwork + 1

        outfile.write ('LD      {0}\n'.format(memory))   #LD M_Step
        nextStep = nextStep + 1
    
        # action-string zerlegen und als actions reinschreiben
        parse_actions (action, outfile, digOutDict)

print '... done'

print
print 'Created memory list:'
for step in stepList:
    print step[4].ljust(5), step[1]
for transition in transitionList:
    print transition[6].ljust(5), transition[1]

print

outfile.write('END_ORGANIZATION_BLOCK\nSUBROUTINE_BLOCK SBR_0:SBR0\nTITLE=SUBROUTINE COMMENTS\nBEGIN\nNetwork 1 // Network Title\n// Network Comment\nEND_SUBROUTINE_BLOCK\nINTERRUPT_BLOCK INT_0:INT0\nTITLE=INTERRUPT ROUTINE COMMENTS\nBEGIN\nNetwork 1 // Network Title\n// Network Comment\nEND_INTERRUPT_BLOCK\n')
outfile.close()
print 'finished successfully :-)'

